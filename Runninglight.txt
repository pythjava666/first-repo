#include "FT64F0AX.h"

// ============ 配置位设置 ============
// 在工程配置中设置：
// FOSC: INTOSC - 内部振荡器
// WDTE: OFF    - 看门狗关闭
// PWRTE: OFF   - 上电延时关闭
// MCLRE: ON    - MCLR引脚功能使能
// CP: OFF      - 代码保护关闭
// CPD: OFF     - 数据EEPROM保护关闭
// BOREN: ON    - 欠压复位使能

// ============ EEPROM相关定义 ============
#define EEPROM_FLAG_ADDR   0x00
#define EEPROM_SPEED_ADDR  0x01
#define EEPROM_DIR_ADDR    0x02    // 新增：方向保存地址

// 速度等级定义
#define MIN_SPEED  1      // 最快
#define MAX_SPEED  10     // 最慢
#define DEFAULT_SPEED 3   // 默认速度

// 流水灯方向定义
#define DIR_LEFT_TO_RIGHT  0  // 从左向右
#define DIR_RIGHT_TO_LEFT  1  // 从右向左

// 共阳极LED模式数组
const unsigned char led_patterns_common_anode[] = {
    0xFE,  // 11111110 - PB0亮 (输出0)，其他灭
    0xFD,  // 11111101 - PB1亮
    0xFB,  // 11111011 - PB2亮
    0xF7,  // 11110111 - PB3亮
    0xEF,  // 11101111 - PB4亮
    0xDF,  // 11011111 - PB5亮
    0xBF,  // 10111111 - PB6亮
    0x7F   // 01111111 - PB7亮
};

// 全局变量
unsigned char run_speed = DEFAULT_SPEED;  // 当前速度等级
unsigned char speed_saved_flag = 0;       // 速度已保存标志
unsigned char dir_saved_flag = 0;         // 方向已保存标志
unsigned char led_position = 0;           // 当前LED位置
unsigned char flow_direction = DIR_LEFT_TO_RIGHT;  // 流动方向

// 函数声明
void POWER_INITIAL(void);
void GPIO_INITIAL(void);
void EEPROM_Write(unsigned char addr, unsigned char data);
unsigned char EEPROM_Read(unsigned char addr);
void Save_Speed_To_EEPROM(void);
void Read_Speed_From_EEPROM(void);
void Save_Direction_To_EEPROM(void);   // 新增：保存方向函数
void Read_Direction_From_EEPROM(void); // 新增：读取方向函数
void Unlock_Flash(void);

// ============ 主函数 ============
void main(void)
{
    // 1. 初始化
    POWER_INITIAL();
    GPIO_INITIAL();
    
    // 2. 从EEPROM读取保存的速度和方向
    Read_Speed_From_EEPROM();
    Read_Direction_From_EEPROM();
    
    // 3. 初始显示
    led_position = 0;
    PORTB = led_patterns_common_anode[0];
    
    // 4. 主循环
    while(1)
    {
        unsigned int delay_time;
        
        // ==================== 按键处理 ====================
        // PA5: 加速键，PA4: 减速键，PA3: 方向切换键
        
        // 加速键（PA5）按下
        if (PA5 == 0)
        {
            // 加速
            if (run_speed > MIN_SPEED)
            {
                run_speed--;
                speed_saved_flag = 0;  // 需要重新保存
                
                // 短暂闪烁提示
                PORTB = 0x00;  // 全亮
                for(volatile int d=0; d<3000; d++);
                PORTB = led_patterns_common_anode[led_position];
            }
            
            // 等待按键释放
            while(PA5 == 0);
        }
        
        // 减速键（PA4）按下
        if (PA4 == 0)
        {
            // 减速
            if (run_speed < MAX_SPEED)
            {
                run_speed++;
                speed_saved_flag = 0;  // 需要重新保存
                
                // 短暂闪烁提示
                PORTB = 0xFF;  // 全灭
                for(volatile int d=0; d<3000; d++);
                PORTB = led_patterns_common_anode[led_position];
            }
            
            // 等待按键释放
            while(PA4 == 0);
        }
        
        // 方向切换键（PA3）按下
        if (PA3 == 0)
        {
            // 切换方向
            if (flow_direction == DIR_LEFT_TO_RIGHT)
            {
                flow_direction = DIR_RIGHT_TO_LEFT;
            }
            else
            {
                flow_direction = DIR_LEFT_TO_RIGHT;
            }
            dir_saved_flag = 0;  // 需要重新保存
            
            // 方向切换提示：双向流水一次
            unsigned char temp_pattern = PORTB;
            for(int i=0; i<8; i++)
            {
                PORTB = led_patterns_common_anode[i];
                for(volatile int d=0; d<2000; d++);
            }
            for(int i=6; i>0; i--)  // 从6开始，避免重复
            {
                PORTB = led_patterns_common_anode[i];
                for(volatile int d=0; d<2000; d++);
            }
            PORTB = temp_pattern;
            
            // 等待按键释放
            while(PA3 == 0);
        }
        
        // ==================== 保存数据到EEPROM ====================
        // 保存速度到EEPROM
        if (speed_saved_flag == 0)
        {
            // 延时后再保存，避免频繁写入
            for(volatile long d=0; d<50000; d++);
            
            // 确保按键已释放
            if (PA5 == 1 && PA4 == 1)
            {
                Save_Speed_To_EEPROM();
                speed_saved_flag = 1;
                
                // 保存成功提示
                unsigned char temp_pattern = PORTB;
                for(int i=0; i<3; i++)
                {
                    PORTB = 0xFF;  // 全灭
                    for(volatile int d=0; d<2000; d++);
                    PORTB = 0x00;  // 全亮
                    for(volatile int d=0; d<2000; d++);
                }
                PORTB = temp_pattern;
            }
        }
        
        // 保存方向到EEPROM
        if (dir_saved_flag == 0)
        {
            // 延时后再保存
            for(volatile long d=0; d<50000; d++);
            
            // 确保所有按键都释放
            if (PA3 == 1 && PA5 == 1 && PA4 == 1)
            {
                Save_Direction_To_EEPROM();
                dir_saved_flag = 1;
                
                // 方向保存提示：闪烁当前方向两次
                unsigned char temp_pattern = PORTB;
                for(int i=0; i<2; i++)
                {
                    PORTB = 0xFF;  // 全灭
                    for(volatile int d=0; d<1000; d++);
                    PORTB = temp_pattern;
                    for(volatile int d=0; d<1000; d++);
                }
            }
        }
        
        // ==================== 流水灯控制 ====================
        delay_time = run_speed * 6000;
        
        // 延时
        for(volatile unsigned long i=0; i<delay_time; i++);
        
        // 根据当前方向更新LED位置
        if(flow_direction == DIR_LEFT_TO_RIGHT)
        {
            // 从左向右流动
            if(led_position == 0)
                led_position = 7;
            else
                led_position--;
        }
        else
        {
            // 从右向左流动
            led_position++;
            if(led_position >= 8)
                led_position = 0;
        }
        
        // 更新显示
        PORTB = led_patterns_common_anode[led_position];
    }
}

// ============ 电源和GPIO初始化 ============
void POWER_INITIAL(void)
{
    // 时钟配置
    OSCCON = 0B01100001;
    
    // 关闭所有中断
    INTCON = 0x00;
    
    // 关闭看门狗
    WDTCON = 0x00;
}

void GPIO_INITIAL(void)
{
    // FT64F0AX只有ANSELA，没有ANSELB和ANSELC
    ANSELA = 0x00;  // 关闭PA口的模拟功能
    
    // 设置方向，增加PA3为输入
    TRISA = 0x38;   // PA3、PA4和PA5为输入(00111000)
    TRISB = 0x00;   // PB全部输出
    
    // 初始输出 - 共阳极：初始所有灯灭（输出1）
    PORTA = 0x00;
    PORTB = 0xFF;   // 所有输出1，LED灭
    
    // 按键上拉 - PA3、PA4和PA5
    WPUA = 0x38;    // PA3、PA4和PA5上拉
    
    // 短暂延时确保稳定
    for(volatile int i=0; i<1000; i++);
}

// ============ EEPROM操作函数 ============
void EEPROM_Write(unsigned char addr, unsigned char data)
{
    // 禁用中断
    while(GIE)
    {
        GIE = 0;
        asm("nop");
        asm("nop");
    }
    
    EEADRL = addr;
    EEDATL = data;
    
    CFGS = 0;     // 访问数据EEPROM
    EEPGD = 0;    // 访问数据存储器
    WREN = 1;     // 允许写操作
    EEIF = 0;     // 清除写完成标志
    
    // 解锁序列
    Unlock_Flash();
    
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    
    // 等待写完成
    while(WR);
    
    WREN = 0;     // 禁止写操作
    GIE = 1;      // 恢复中断
}

unsigned char EEPROM_Read(unsigned char addr)
{
    unsigned char data;
    
    // 禁用中断
    while(GIE)
    {
        GIE = 0;
        asm("nop");
        asm("nop");
    }
    
    EEADRL = addr;
    CFGS = 0;     // 访问数据EEPROM
    EEPGD = 0;    // 访问数据存储器
    RD = 1;       // 启动读操作
    
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    
    data = EEDATL;  // 读取数据
    
    GIE = 1;        // 恢复中断
    
    return data;
}

// Flash解锁序列
void Unlock_Flash(void)
{
    asm("MOVLW 0x03");
    asm("MOVWF _BSREG");
    asm("MOVLW 0x55");
    asm("MOVWF _EECON2");
    asm("MOVLW 0xAA");
    asm("MOVWF _EECON2");
    asm("BSF _EECON1, 1");  // 置位WR位
    asm("nop");
    asm("nop");
}

// ============ 保存速度到EEPROM ============
void Save_Speed_To_EEPROM(void)
{
    // 先写标志位，再写速度数据
    EEPROM_Write(EEPROM_FLAG_ADDR, 0xAA);      // 标志位，表示有保存的数据
    EEPROM_Write(EEPROM_SPEED_ADDR, run_speed); // 保存速度值
}

// ============ 保存方向到EEPROM ============
void Save_Direction_To_EEPROM(void)
{
    EEPROM_Write(EEPROM_DIR_ADDR, flow_direction);  // 保存方向值
}

// ============ 从EEPROM读取速度 ============
void Read_Speed_From_EEPROM(void)
{
    unsigned char flag = EEPROM_Read(EEPROM_FLAG_ADDR);
    
    if (flag == 0xAA)  // 检查标志位
    {
        run_speed = EEPROM_Read(EEPROM_SPEED_ADDR);
        
        // 验证速度值是否有效
        if (run_speed < MIN_SPEED || run_speed > MAX_SPEED)
        {
            run_speed = DEFAULT_SPEED;  // 无效则使用默认值
        }
    }
    else
    {
        run_speed = DEFAULT_SPEED;  // 无保存数据则使用默认值
    }
    
    speed_saved_flag = 1;  // 标记为已保存
}

// ============ 从EEPROM读取方向 ============
void Read_Direction_From_EEPROM(void)
{
    unsigned char saved_dir = EEPROM_Read(EEPROM_DIR_ADDR);
    
    // 验证方向值是否有效
    if (saved_dir == DIR_LEFT_TO_RIGHT || saved_dir == DIR_RIGHT_TO_LEFT)
    {
        flow_direction = saved_dir;
    }
    else
    {
        flow_direction = DIR_LEFT_TO_RIGHT;  // 无效则使用默认方向
    }
    
    dir_saved_flag = 1;  // 标记为已保存
}